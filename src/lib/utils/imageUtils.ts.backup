/**
 * Image processing utilities for the application
 */

/**
 * Convert ArrayBuffer to Base64 string
 * @param buffer - ArrayBuffer to convert
 * @returns Base64 encoded string
 */
export const arrayBufferToBase64 = (buffer: ArrayBuffer): string => {
  let binary = '';
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i = 0; i < len; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return window.btoa(binary);
};

/**
 * Convert File to Base64 string using ArrayBuffer
 * @param file - File to convert
 * @param includeDataPrefix - Whether to include data URL prefix
 * @returns Promise<string> - Base64 encoded string
 */
export const fileToBase64 = async (
  file: File,
  includeDataPrefix: boolean = false,
): Promise<string> => {
  const arrayBuffer = await file.arrayBuffer();
  const base64 = arrayBufferToBase64(arrayBuffer);

  if (includeDataPrefix) {
    const mimeType = file.type || 'image/jpeg';
    return `data:${mimeType};base64,${base64}`;
  }

  return base64;
};

/**
 * Convert File to Base64 string using FileReader (legacy method)
 * @param file - File to convert
 * @returns Promise<string> - Base64 encoded string
 */
export const fileToBase64Legacy = async (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (event) => {
      const result = event.target?.result as string;
      const base64String = result.split(',')[1]; // Remove data URL prefix
      resolve(base64String);
    };
    reader.onerror = reject;
    reader.readAsDataURL(file);
  });
};

/**
 * Compress image with quality and size optimization
 * @param file - Image file to compress
 * @param options - Compression options
 * @returns Promise<string> - Compressed Base64 string
 */
export const compressImage = async (
  file: File,
  options: {
    maxSizeBytes?: number;
    maxWidth?: number;
    maxHeight?: number;
    quality?: number;
    format?: 'jpeg' | 'png' | 'webp';
    includeDataPrefix?: boolean;
  } = {},
): Promise<string> => {
  const {
    maxSizeBytes = 2 * 1024 * 1024, // 2MB
    maxWidth = 1200,
    maxHeight = 800,
    quality = 0.9,
    format = 'jpeg',
    includeDataPrefix = false,
  } = options;

  // If file is already small enough, return as-is
  if (file.size <= maxSizeBytes) {
    return fileToBase64(file);
  }

  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = (event) => {
      const img = new Image();

      img.onload = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        if (!ctx) {
          reject(new Error('Failed to get canvas context'));
          return;
        }

        // Calculate new dimensions maintaining aspect ratio
        let { width, height } = img;
        if (width > maxWidth || height > maxHeight) {
          const ratio = Math.min(maxWidth / width, maxHeight / height);
          width = Math.round(width * ratio);
          height = Math.round(height * ratio);
        }

        canvas.width = width;
        canvas.height = height;

        // Enable high-quality image smoothing
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = 'high';

        // Draw and compress image
        ctx.drawImage(img, 0, 0, width, height);

        try {
          const mimeType = `image/${format}`;
          const compressedDataUrl = canvas.toDataURL(mimeType, quality);
          const base64String = compressedDataUrl.split(',')[1];

          if (includeDataPrefix) {
            resolve(compressedDataUrl);
          } else {
            resolve(base64String);
          }
        } catch (error) {
          reject(error);
        }
      };

      img.onerror = () => reject(new Error('Failed to load image'));
      img.src = event.target?.result as string;
    };

    reader.onerror = () => reject(new Error('Failed to read file'));
    reader.readAsDataURL(file);
  });
};

/**
 * Validate image file
 * @param file - File to validate
 * @param options - Validation options
 * @returns Validation result
 */
export const validateImageFile = (
  file: File,
  options: {
    maxSizeBytes?: number;
    allowedTypes?: string[];
  } = {},
): { isValid: boolean; error?: string } => {
  const {
    maxSizeBytes = 10 * 1024 * 1024, // 10MB
    allowedTypes = ['image/jpeg', 'image/png', 'image/webp', 'image/gif'],
  } = options;

  if (!file.type.startsWith('image/')) {
    return { isValid: false, error: 'Please select an image file' };
  }

  if (!allowedTypes.includes(file.type)) {
    return { isValid: false, error: `File type ${file.type} is not supported` };
  }

  if (file.size > maxSizeBytes) {
    return {
      isValid: false,
      error: `Image size must be less than ${Math.round(maxSizeBytes / 1024 / 1024)}MB`,
    };
  }

  return { isValid: true };
};

/**
 * Get image dimensions from file
 * @param file - Image file
 * @returns Promise with image dimensions
 */
export const getImageDimensions = (file: File): Promise<{ width: number; height: number }> => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      resolve({ width: img.width, height: img.height });
    };
    img.onerror = () => reject(new Error('Failed to load image'));
    img.src = URL.createObjectURL(file);
  });
};

/**
 * Analyze Base64 image size and provide recommendations
 * @param base64String - Base64 encoded image string
 * @param context - Context for logging (e.g., 'thumbnail', 'profile', 'content')
 * @returns Analysis result with recommendations
 */
export const analyzeBase64Size = (base64String: string, context: string = 'image') => {
  const base64Length = base64String.length;
  const estimatedBytes = Math.round((base64Length * 3) / 4);
  const estimatedKB = (estimatedBytes / 1024).toFixed(2);
  const estimatedMB = (estimatedBytes / (1024 * 1024)).toFixed(2);

  // ì‹¤ë¬´ ê¸°ì¤€ë³„ í‰ê°€
  const analysis = {
    base64Length,
    estimatedBytes,
    estimatedKB,
    estimatedMB,
    sizeCategory: '' as string,
    recommendation: '' as string,
    isOptimal: false,
    warnings: [] as string[],
  };

  // í¬ê¸° ì¹´í…Œê³ ë¦¬ ë¶„ë¥˜
  if (base64Length <= 135000) {
    analysis.sizeCategory = 'Small (â‰¤100KB)';
    analysis.isOptimal = true;
    analysis.recommendation = 'âœ… ìµœì  í¬ê¸°ì…ë‹ˆë‹¤.';
  } else if (base64Length <= 675000) {
    analysis.sizeCategory = 'Medium (â‰¤500KB)';
    analysis.isOptimal = true;
    analysis.recommendation = 'âœ… ê¶Œì¥ í¬ê¸°ì…ë‹ˆë‹¤.';
  } else if (base64Length <= 1350000) {
    analysis.sizeCategory = 'Large (â‰¤1MB)';
    analysis.isOptimal = false;
    analysis.recommendation = 'âš ï¸ ëª¨ë°”ì¼ì—ì„œ ë¡œë”©ì´ ëŠë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.';
    analysis.warnings.push('ëª¨ë°”ì¼ ì„±ëŠ¥ ê³ ë ¤ í•„ìš”');
  } else if (base64Length <= 2700000) {
    analysis.sizeCategory = 'Very Large (â‰¤2MB)';
    analysis.isOptimal = false;
    analysis.recommendation = 'âš ï¸ ì„œë²„ ì œí•œì— ê·¼ì ‘í•©ë‹ˆë‹¤.';
    analysis.warnings.push('ì„œë²„ ì œí•œ ìœ„í—˜');
    analysis.warnings.push('ë„¤íŠ¸ì›Œí¬ ì„±ëŠ¥ ì €í•˜');
  } else {
    analysis.sizeCategory = 'Too Large (>2MB)';
    analysis.isOptimal = false;
    analysis.recommendation = 'âŒ ì••ì¶•ì´ í•„ìš”í•©ë‹ˆë‹¤.';
    analysis.warnings.push('ì„œë²„ ì œí•œ ì´ˆê³¼ ìœ„í—˜');
    analysis.warnings.push('ë„¤íŠ¸ì›Œí¬ íƒ€ì„ì•„ì›ƒ ê°€ëŠ¥ì„±');
    analysis.warnings.push('ì‚¬ìš©ì ê²½í—˜ ì €í•˜');
  }

  // ì»¨í…ìŠ¤íŠ¸ë³„ ì¶”ê°€ ê¶Œì¥ì‚¬í•­
  if (context === 'thumbnail' && base64Length > 675000) {
    analysis.recommendation += ' ì¸ë„¤ì¼ì€ 500KB ì´í•˜ ê¶Œì¥.';
  } else if (context === 'profile' && base64Length > 1350000) {
    analysis.recommendation += ' í”„ë¡œí•„ ì´ë¯¸ì§€ëŠ” 1MB ì´í•˜ ê¶Œì¥.';
  }

  return analysis;
};

/**
 * Log Base64 size analysis with detailed information
 * @param base64String - Base64 encoded image string
 * @param context - Context for logging
 * @param options - Logging options
 */
export const logBase64Analysis = (
  base64String: string,
  context: string = 'image',
  options: {
    showDetails?: boolean;
    showWarnings?: boolean;
    showRecommendations?: boolean;
  } = {},
) => {
  const { showDetails = true, showWarnings = true, showRecommendations = true } = options;

  const analysis = analyzeBase64Size(base64String, context);

  console.group(`ğŸ“Š Base64 í¬ê¸° ë¶„ì„ (${context})`);

  if (showDetails) {
    console.log(`ğŸ“ í¬ê¸° ì •ë³´:`);
    console.log(`  - Base64 ê¸¸ì´: ${analysis.base64Length.toLocaleString()} chars`);
    console.log(`  - ì˜ˆìƒ íŒŒì¼ í¬ê¸°: ${analysis.estimatedKB} KB (${analysis.estimatedMB} MB)`);
    console.log(`  - ì¹´í…Œê³ ë¦¬: ${analysis.sizeCategory}`);
  }

  if (showWarnings && analysis.warnings.length > 0) {
    console.warn(`âš ï¸ ì£¼ì˜ì‚¬í•­:`);
    analysis.warnings.forEach((warning) => {
      console.warn(`  - ${warning}`);
    });
  }

  if (showRecommendations) {
    if (analysis.isOptimal) {
      console.log(`âœ… ${analysis.recommendation}`);
    } else {
      console.warn(`ğŸ’¡ ${analysis.recommendation}`);
    }
  }

  // ë„¤íŠ¸ì›Œí¬ ì „ì†¡ í¬ê¸° ì¶”ì • (gzip ì••ì¶• ê³ ë ¤)
  const networkSizeKB = Math.ceil((analysis.base64Length * 1.1) / 1024);
  console.log(`ğŸŒ ë„¤íŠ¸ì›Œí¬ ì „ì†¡ í¬ê¸°: ${networkSizeKB} KB (gzip ì••ì¶• ê³ ë ¤)`);

  console.groupEnd();

  return analysis;
};

/**
 * Get compression recommendations based on Base64 size
 * @param base64String - Base64 encoded image string
 * @returns Compression recommendations
 */
export const getCompressionRecommendations = (base64String: string) => {
  const analysis = analyzeBase64Size(base64String);

  const recommendations = {
    needsCompression: false,
    suggestedQuality: 0.9,
    suggestedMaxWidth: 1200,
    suggestedMaxHeight: 800,
    suggestedFormat: 'jpeg' as 'jpeg' | 'png' | 'webp',
    reasons: [] as string[],
  };

  if (analysis.base64Length > 1350000) {
    recommendations.needsCompression = true;
    recommendations.suggestedQuality = 0.7;
    recommendations.suggestedMaxWidth = 800;
    recommendations.suggestedMaxHeight = 600;
    recommendations.reasons.push('1MB ì´ˆê³¼ë¡œ ì••ì¶• í•„ìš”');
  }

  if (analysis.base64Length > 2700000) {
    recommendations.needsCompression = true;
    recommendations.suggestedQuality = 0.6;
    recommendations.suggestedMaxWidth = 600;
    recommendations.suggestedMaxHeight = 400;
    recommendations.reasons.push('2MB ì´ˆê³¼ë¡œ ê°•ë ¥í•œ ì••ì¶• í•„ìš”');
  }

  if (analysis.base64Length > 4000000) {
    recommendations.needsCompression = true;
    recommendations.suggestedQuality = 0.5;
    recommendations.suggestedMaxWidth = 400;
    recommendations.suggestedMaxHeight = 300;
    recommendations.reasons.push('4MB ì´ˆê³¼ë¡œ ê·¹í•œ ì••ì¶• í•„ìš”');
  }

  return recommendations;
};

/**
 * ì´ë¯¸ì§€ URL ìœ íš¨ì„± ê²€ì‚¬
 */
export const isValidImageUrl = (url: string): boolean => {
  if (!url) return false;
  
  try {
    const urlObj = new URL(url);
    const validProtocols = ['http:', 'https:'];
    const validExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.svg', '.bmp'];
    
    // í”„ë¡œí† ì½œ ê²€ì‚¬
    if (!validProtocols.includes(urlObj.protocol)) {
      return false;
    }
    
    // í™•ì¥ìê°€ ì—†ì–´ë„ ìœ íš¨í•  ìˆ˜ ìˆìŒ (API ì‘ë‹µ ë“±)
    return true;
  } catch {
    return false;
  }
};

/**
 * ì´ë¯¸ì§€ URLì„ ì•ˆì „í•œ URLë¡œ ë³€í™˜
 */
export const sanitizeImageUrl = (url: string): string | null => {
  if (!url) return null;
  
  try {
    const urlObj = new URL(url);
    return urlObj.toString();
  } catch {
    return null;
  }
};

/**
 * ì´ë¯¸ì§€ ë¡œë”© ì—ëŸ¬ ì²˜ë¦¬
 */
export const handleImageError = (event: React.SyntheticEvent<HTMLImageElement, Event>, fallbackUrl?: string) => {
  const target = event.target as HTMLImageElement;
  
  if (fallbackUrl && target.src !== fallbackUrl) {
    target.src = fallbackUrl;
  } else {
    // ì´ë¯¸ì§€ë¥¼ ìˆ¨ê¸°ê³  ì—ëŸ¬ ìƒíƒœ í‘œì‹œ
    target.style.display = 'none';
    const parent = target.parentElement;
    if (parent) {
      parent.classList.add('image-error');
    }
  }
};
